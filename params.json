{"name":"Xv6-loongson3a","tagline":"An experimental operating system running on MIPS64 for educational purpose (WIP)","body":"### My first project homepage!\r\nI figured out recently that GitHub projects can have their own homepages!  And I'll gradually add my thoughts and experiences here while continuing my development.\r\n\r\nSo, here's a brief overview of what I'm doing:\r\n\r\nThe two teaching operating systems, [xv6](http://pdos.csail.mit.edu/6.828/2014/xv6.html) and [uCore](https://github.com/chyyuu/ucore_lab) (Chinese, with ~~poor~~ ~~Chin~~English in source code) are presented in the class I attended last year, both of which run on i386 architecture.  My instructor proposed to port them to a 64-bit (which is widely preferred today), different architecture, a RISC one if possible.  So... I'm in.\r\n\r\nxv6 is a clean and complete OS, with necessary (though not all) services and functions implemented: process isolation, scheduler, file systems, system calls, and most of all, multiprocessor support.  It also provides a bunch of userland programs.  The only thing I dislike is... well, indentation.\r\n\r\nuCore integrates some concepts from Linux, and slightly organizes the source code, but it constantly annoys me by brutally interrupts console outputs with those from other processes (as it dumps character by character rather than printing an entire buffer out).  It also provides less system calls, and thus, less kernel functions.  Moreover, it lacks multiprocessor support (although a serious one, called [uCore Plus](https://github.com/chyyuu/ucore_plus), is able to run on multicore systems, and even have NUMA support), and maintains concurrency disgracefully by turning on/off interrupts.\r\n\r\nSo I'm trying my best to write an operating system which combines highlights from both operating systems, on a totally different architecture.  My instructor suggests Loongson 3A, a family of MIPS64.  I have to deal with issues particularly related to 64-bit architectures, and problems about MIPS.\r\n\r\nMy available device is a [multitech board](http://www.loongson.cn/multi_techboard.php).  It doesn't have hard disks.\r\n\r\nHere's my roadmap:  \r\n1. Boot it up (Completed)  \r\n2. Physical page management (Completed)  \r\n3. Virtual memory management and SLAB allocation (Completed)  \r\n4. Processes, context switches, user mode isolation (Completed)  \r\n5. Userland C runtime (Now in progress...)  \r\n6. Scheduler (Now in progress...)  \r\n7. `fork(2)`, `exit(2)`, `wait(2)`, `kill(2)`, with same arguments as those specified in POSIX (Not yet)  \r\n8. Process memory sharing and copy-on-write (Not yet)  \r\n9. Concurrency maintaining through locks (Not yet)  \r\n10. File system, including devfs (Not yet, disk file system impossible for lacking of hard disks, may have to create a ramdisk or implement `tmpfs`?)  \r\n11. Necessary userland applications (Not yet)  \r\n12. SMP Multiprocessor support (Not yet)  \r\n\r\nMy plans (or more precisely, daydreams)  \r\n13. Signals (to prevent userland programs from crashing kernels)  \r\n14. Security (although I frequently create bugs and frustrates myself)  \r\n15. Dynamic linking (which means I have to create a dynamic C runtime library on my own)  \r\n16. Cleaner code and organization (I struggle to stick on Linus' coding standard and tried to write better, but some of my code is still messy)  \r\n16. Berkeley FFS (I have to read the paper and Linux source code)  ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}