{"name":"xv6-loongson3a","tagline":"An experimental operating system running on MIPS64 for educational purpose (WIP)","body":"### My first project homepage!\r\nI figured out recently that GitHub projects can have their own homepages!  And I'll gradually add my thoughts and experiences here while continuing my development.\r\n\r\nSo, here's a brief overview of what I'm doing:\r\n\r\nThe two teaching operating systems, [xv6](http://pdos.csail.mit.edu/6.828/2014/xv6.html) and [uCore](https://github.com/chyyuu/ucore_lab) (Chinese, with ~~poor~~ ~~Chin~~English in source code) are presented in the class I attended last year, both of which run on i386 architecture.  My instructor proposed to port them to a 64-bit (which is widely preferred today), different architecture, a RISC one if possible.  So... I'm in.\r\n\r\nxv6 is a clean and complete OS, with necessary (though not all) services and functions implemented: process isolation, scheduler, file systems, system calls, and most of all, multiprocessor support.  It also provides a bunch of userland programs.  The only thing I dislike is... well, indentation.\r\n\r\nuCore integrates some concepts from Linux, and slightly organizes the source code, but it constantly annoys me by brutally interrupts console outputs with those from other processes (as it dumps character by character rather than printing an entire buffer out).  It also provides less system calls, and thus, less kernel functions.  Moreover, it lacks multiprocessor support (although a serious one, called [uCore Plus](https://github.com/chyyuu/ucore_plus), is able to run on multicore systems, and even have NUMA support), and maintains concurrency disgracefully by turning on/off interrupts.\r\n\r\nSo I'm trying my best to write an operating system which combines highlights from both operating systems, on a totally different architecture.  My instructor suggests Loongson 3A, a family of MIPS64.  I have to deal with issues particularly related to 64-bit architectures, and problems about MIPS.\r\n\r\nMy available device is a [multitech board](http://www.loongson.cn/multi_techboard.php).  It doesn't have hard disks.\r\n\r\nHere's my roadmap:\r\n\r\n1. Boot it up (Completed)\r\n2. Physical page management (Completed)\r\n3. Virtual memory management and SLAB allocation (Completed)\r\n4. Processes, context switches, user mode isolation (Completed)\r\n5. Userland C runtime (Now in progress...)\r\n6. Scheduler (Now in progress...)\r\n7. `fork(2)`, `exit(2)`, `wait(2)`, `kill(2)`, with same arguments as those specified in POSIX (Not yet)\r\n8. Process memory sharing and copy-on-write (Not yet)\r\n9. Concurrency maintaining through locks (Not yet)\r\n10. File system, including devfs (Not yet, disk file system impossible for lacking of hard disks, may have to create a ramdisk or implement `tmpfs`?)\r\n11. Necessary userland applications (Not yet)\r\n12. SMP Multiprocessor support (Not yet)  \r\n\r\nMy plans (or more precisely, daydreams)\r\n\r\n13. Signals (to prevent userland programs from crashing kernels)\r\n14. Security (although I frequently create bugs and frustrates myself)\r\n15. Dynamic linking (which means I have to create a dynamic C runtime library on my own)\r\n16. Cleaner code and organization (I struggle to stick on Linus' coding standard and tried to write better, but some of my code is still messy)\r\n16. Berkeley FFS (I have to read the paper and Linux source code)\r\n\r\n### Booting up (2015/01/25 to 2015/01/27)\r\nAs I said, the [multi techboard](http://www.loongson.cn/multi_techboard.php) does not have hard disks.  So, rather than booting from disks, the box connects to a host with TFTP service enabled, downloads the kernel, loads it into RAM, and finally starts up.\r\n\r\nOriginally, there's a Linux kernel specifically modified by Loongson Technology for the box is available, with NFSv2 support, which is already obsoleted by my Fedora 21 laptop...\r\n\r\nAnyway, after referencing the [Linux/MIPS Porting Guide](http://www.linux-mips.org/wiki/Porting), I found a guide and sample code for how to write a [Hello World](http://linux.junsun.net/porting-howto/src/barebone/) for a MIPS.\r\n\r\nI wrote the UART serial driver according to Jun Sun's guide and [Loongson 3A User Manual Volume 1](http://www.loongson.cn/uploadfile/201204/Loongson3A_processor_user_manual_P1_V1.11.pdf), and, unsurprisingly, nothing came out.\r\n\r\nI'm neither a MIPS expert or an operating system master.  Since there's no EJTAG device with me, I developed a brute-force debugging method, that is, to manually insert breakpoints (thanks to MIPS that it has a breakpoint instruction) in different places.  Careful review of [See MIPS Run](http://www.amazon.com/Second-Edition-Kaufmann-Computer-Architecture/dp/0120884216) revealed that the very first instruction\r\n\r\n    mtc0    zero, CP0_STATUS\r\n\r\nactually totally disabled the coprocessor 0, thereby preventing other `mtc0` instructions from committing changes.  The correct way for manually disabling interrupts is to clear the IE bit inside coprocessor 0.\r\n\r\nI also had to change the UART address since that of the box differs from the guide.  I dived into Linux code to figure out the corresponding virtual address, given physical address, until later I understand how MIPS64 address translation works, at which point I realized that I did a lot of unnecessary work previously.\r\n\r\nUART driver is very simple to implement, as reading from and writing to some fixed virtual address would do everything, from serial control to reading or writing data.\r\n\r\nAfter changing the first instruction and adding kernel stack allocation (by assigning a reasonable value to SP), the box finally greeted me with a warm Hello World message.\r\n\r\n### MIPS Hardware Exception Handling\r\nThe next goal is to handle various exceptions, which inevitably involves hardware exception handling mechanisms, and linking C code with a bunch of MIPS assembly code.  In this section we try to picture what would happen if the CPU encounters an exception.\r\n\r\nPrior to discussing exception handling, I should mention the *delayed branches*, one of the MIPS pipeline side effects.  It is well-known that conditional jumps may easily delay the pipeline execution and reduce efficiency.  MIPS attempts to address this control hazard by making instructions directly succeeding a branch *always* be executed.  The instruction immediately following a branch is called to be inside a *branch delay slot*.\r\n\r\nMIPS is a kind of *precise exception* CPU, that is, when an exception occur, all instruction preceding one certain instruction, called victim, is complete, but it's as if the victim and everything succeeding it were never started.  The victim address is stored inside Exception Program Counter (EPC) inside coprocessor 0 (CP0).\r\n\r\nMIPS hardware exception handling is simple.  The CPU first stores the victim address, usually that of the exception-generating instruction (or the instruction to be executed during an interrupt), unless it is inside a branch delay slot, in which case the branch instruction address is stored, inside EPC, to maintain the precise exception property.  It then switches on Exception Level (EXL) in CP0 Status register, and jumps into a fixed exception entry address based on what kind of exception it needs to handle.  All exceptions, e.g. interrupts, system calls, are handled this way.\r\n\r\nThe `eret` instruction finishes exception handling by switching off EXL and restoring program counter from EPC.  Often EPC is left unchanged during exception handling, in which case the CPU restarts the victim and tries to continue execution.\r\n\r\nThe exception entry addresses are selected by exception type and Base Exception Vector (BEV) bit in Status register.  MIPS chooses ones residing in ROM (`0xFFFF FFFF BFC0 xxxx`) if BEV is set, or those in RAM if BEV is not set.  In my box, BEV is already cleared by BIOS, and there's no need to change BEV back to 1.\r\n\r\nThe RAM exception entry points are determined by the CP0 Exception Base (EBASE) register, plus some offsets:\r\n\r\n1. `EBASE + 0x000`: TLB refilling, which will be discussed later.\r\n2. `EBASE + 0x080`: 64-bit extended TLB refilling, ditto.\r\n3. `EBASE + 0x100`: Cache error, usually won't happen.\r\n4. `EBASE + 0x180`: Everything else.\r\n5. `EBASE + 0x200 + ...`: These address are for vectored interrupts, but I didn't and won't use this feature.\r\n\r\nIn the next section I'll briefly cover how C code works together with assembly, which involves the MIPS Application Binary Interface (ABI).\r\n\r\n### MIPS64 Application Binary Interface (ABI)\r\nIn a word, ABI is about stack frames and layouts, manner of passing arguments, and ways of properly organizing and aligning data.  ABI plays a major role in operating system development since most code would be written in C, which would be then translated into assembly by some compiler (usually GNU C Compiler) according to some standards, which would be in turn linked with a small portion of code have to be assembly for tasks which could not be completed by C such as:\r\n\r\n1. Preserving and switching thread contexts, that is, to save and restore register sets.\r\n2. Exception handling, which involves register preservation as well.\r\n3. Some of the hardware-specific tasks, such as TLB refilling or cache management on MIPS, or performing PCI I/O on x86, or accessing coprocessors on MIPS or ARM.\r\n\r\nIn my project I used the SGI `n64` ABI, which is for 64-bit MIPS CPUs.  I'll list some but not all of the declarations here:\r\n\r\n* Register Usage:\r\n  - `zero($0)`: *Wired zero*.\r\n  - `at($1)`: *Assembler temporary* register, usually for holding intermediate results.  Rarely used directly in assembler code.\r\n  - `v0($2)`, `v1($3)`: Holds return values of a function.  In most cases a single `v0` would suffice, but in current Linux or other implementations `v0` and `v1` together holds the pair of file descriptors returned by `pipe(2)`.\r\n  - `a0($4)`, `a1($5)`, `a2($6)`, `a3($7)`: Holds the first four arguments when calling a function.\r\n  - `a4($8)`, `a5($9)`, `a6($10)`, `a7($11)`: Holds the fifth to the eighth argument when calling a function.  They are named `t0`, `t1`, `t2`, `t3` in my code currently as these names are from the older `o32` standard, where they serve as *temporary* (or *caller-saved*, indicating that it's function caller's responsibility to preserve them) registers.  Someday I'll fix that.\r\n  - `t0($12)`, `t1($13)`, `t2($14)`, `t3($15)`: *Temporary*, or \"*caller-saved*\" registers.  They are not necessary preserved between function calls, and programs must consider them volatile.  They are named `t4`, `t5`, `t6`, `t7` in my code, due to historical reasons, and again, someday I'll fix those.\r\n  - `s0($16)` to `s7($23)`: *Static*, or \"*callee-saved*\" registers.  Values there must be preserved onto function stack between different function calls.\r\n  - `t8($24)`, `t9($25)`: Yet another two temporary registers.  `t9` have another purpose of holding address of called function in *Position-Independent Code* (PIC), but I'm not considering about implementing PIC until I start working on dynamic linking, if I have time.\r\n  - `k0($26)`, `k1($27)`: Reserved for exception handlers, normally should not be used elsewhere.\r\n  - `gp($28)`: *Global pointer*.  Literally, this register retains global variable.  `gp` may point to *Global Offset Table* (GOT) in PIC.\r\n  - `sp($29)`: *Stack pointer*.\r\n  - `s8($30)` or `fp($30)`: *Frame pointer*, which points to top of the stack frame of one function.  The relation between `fp` and `sp` somehow resembles that between `ESP` and `EBP` in `i386`.\r\n  - `ra($31)`: Saves the return address of this function.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}