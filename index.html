<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>xv6-loongson3a by BarclayII</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>xv6-loongson3a</h1>
        <h2>An experimental operating system running on MIPS64 for educational purpose (WIP)</h2>

        <section id="downloads">
          <a href="https://github.com/BarclayII/xv6-Loongson3A/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/BarclayII/xv6-Loongson3A/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/BarclayII/xv6-Loongson3A" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="mips-exception-handling" class="anchor" href="#mips-exception-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>MIPS Exception Handling</h3>

<p>The next goal is to handle various exceptions.</p>

<p>Prior to discussing exception handling, I should mention the <em>delayed branches</em>, one of the MIPS pipeline side effects.  It is well-known that conditional jumps may easily delay the pipeline execution and reduce efficiency.  MIPS attempts to address this control hazard by making instructions directly succeeding a branch <em>always</em> be executed.  The instruction immediately following a branch is called to be inside a <em>branch delay slot</em>.</p>

<p>MIPS is a kind of <em>precise exception</em> CPU, that is, when an exception occur, all instruction preceding one certain instruction, called victim, is complete, but it's as if the victim and everything succeeding it were never started.  The victim address is stored inside Exception Program Counter (EPC) inside coprocessor 0 (CP0).</p>

<p>MIPS hardware exception handling is simple.  The CPU first stores the victim address, usually that of the exception-generating instruction (or the instruction to be executed during an interrupt), unless it is inside a branch delay slot, in which case the branch instruction address is stored, inside EPC, to maintain the precise exception property.  It then switches on Exception Level (EXL) in CP0 Status register, and jumps into a fixed exception entry address based on what kind of exception it needs to handle.  All exceptions, e.g. interrupts, system calls, are handled this way.</p>

<p>The <code>eret</code> instruction finishes exception handling by switching off EXL and restoring program counter from EPC.  Often EPC is left unchanged during exception handling, in which case the CPU restarts the victim and tries to continue execution.</p>

<p>The exception entry addresses are selected by exception type and Base Exception Vector (BEV) bit in Status register.  MIPS chooses ones residing in ROM (<code>0xFFFF FFFF BFC0 xxxx</code>) if BEV is set, or those in RAM if BEV is not set.  In my box, BEV is already cleared by BIOS, and there's no need to change BEV back to 1.</p>

<p>The RAM exception entry points are determined by the CP0 Exception Base (EBASE) register, plus some offsets:
1. <code>EBASE + 0x000</code>: TLB refilling, which will be discussed later.
2. <code>EBASE + 0x080</code>: 64-bit extended TLB refilling, ditto.
3. <code>EBASE + 0x100</code>: Cache error, usually won't happen.
4. <code>EBASE + 0x180</code>: Everything else.
5. <code>EBASE + 0x200 + ...</code>: These address are for vectored interrupts, but I didn't and won't use this feature.</p>

<h3>
<a id="booting-up-20150125-to-20150127" class="anchor" href="#booting-up-20150125-to-20150127" aria-hidden="true"><span class="octicon octicon-link"></span></a>Booting up (2015/01/25 to 2015/01/27)</h3>

<p>As I said, the <a href="http://www.loongson.cn/multi_techboard.php">multi techboard</a> does not have hard disks.  So, rather than booting from disks, the box connects to a host with TFTP service enabled, downloads the kernel, loads it into RAM, and finally starts up.</p>

<p>Originally, there's a Linux kernel specifically modified by Loongson Technology for the box is available, with NFSv2 support, which is already obsoleted by my Fedora 21 laptop...</p>

<p>Anyway, after referencing the <a href="http://www.linux-mips.org/wiki/Porting">Linux/MIPS Porting Guide</a>, I found a guide and sample code for how to write a <a href="http://linux.junsun.net/porting-howto/src/barebone/">Hello World</a> for a MIPS.</p>

<p>I wrote the UART serial driver according to Jun Sun's guide and <a href="http://www.loongson.cn/uploadfile/201204/Loongson3A_processor_user_manual_P1_V1.11.pdf">Loongson 3A User Manual Volume 1</a>, and, unsurprisingly, nothing came out.</p>

<p>I'm neither a MIPS expert or an operating system master.  Since there's no EJTAG device with me, I developed a brute-force debugging method, that is, to manually insert breakpoints (thanks to MIPS that it has a breakpoint instruction) in different places.  Careful review of <a href="http://www.amazon.com/Second-Edition-Kaufmann-Computer-Architecture/dp/0120884216">See MIPS Run</a> revealed that the very first instruction</p>

<pre><code>mtc0    zero, CP0_STATUS
</code></pre>

<p>actually totally disabled the coprocessor 0, thereby preventing other <code>mtc0</code> instructions from committing changes.  The correct way for manually disabling interrupts is to clear the IE bit inside coprocessor 0.</p>

<p>I also had to change the UART address since that of the box differs from the guide.  I dived into Linux code to figure out the corresponding virtual address, given physical address, until later I understand how MIPS64 address translation works, at which point I realized that I did a lot of unnecessary work previously.</p>

<p>UART driver is very simple to implement, as reading from and writing to some fixed virtual address would do everything, from serial control to reading or writing data.</p>

<p>After changing the first instruction and adding kernel stack allocation (by assigning a reasonable value to SP), the box finally greeted me with a warm Hello World message.</p>

<h3>
<a id="my-first-project-homepage" class="anchor" href="#my-first-project-homepage" aria-hidden="true"><span class="octicon octicon-link"></span></a>My first project homepage!</h3>

<p>I figured out recently that GitHub projects can have their own homepages!  And I'll gradually add my thoughts and experiences here while continuing my development.</p>

<p>So, here's a brief overview of what I'm doing:</p>

<p>The two teaching operating systems, <a href="http://pdos.csail.mit.edu/6.828/2014/xv6.html">xv6</a> and <a href="https://github.com/chyyuu/ucore_lab">uCore</a> (Chinese, with <del>poor</del> <del>Chin</del>English in source code) are presented in the class I attended last year, both of which run on i386 architecture.  My instructor proposed to port them to a 64-bit (which is widely preferred today), different architecture, a RISC one if possible.  So... I'm in.</p>

<p>xv6 is a clean and complete OS, with necessary (though not all) services and functions implemented: process isolation, scheduler, file systems, system calls, and most of all, multiprocessor support.  It also provides a bunch of userland programs.  The only thing I dislike is... well, indentation.</p>

<p>uCore integrates some concepts from Linux, and slightly organizes the source code, but it constantly annoys me by brutally interrupts console outputs with those from other processes (as it dumps character by character rather than printing an entire buffer out).  It also provides less system calls, and thus, less kernel functions.  Moreover, it lacks multiprocessor support (although a serious one, called <a href="https://github.com/chyyuu/ucore_plus">uCore Plus</a>, is able to run on multicore systems, and even have NUMA support), and maintains concurrency disgracefully by turning on/off interrupts.</p>

<p>So I'm trying my best to write an operating system which combines highlights from both operating systems, on a totally different architecture.  My instructor suggests Loongson 3A, a family of MIPS64.  I have to deal with issues particularly related to 64-bit architectures, and problems about MIPS.</p>

<p>My available device is a <a href="http://www.loongson.cn/multi_techboard.php">multitech board</a>.  It doesn't have hard disks.</p>

<p>Here's my roadmap:<br>
1. Boot it up (Completed)<br>
2. Physical page management (Completed)<br>
3. Virtual memory management and SLAB allocation (Completed)<br>
4. Processes, context switches, user mode isolation (Completed)<br>
5. Userland C runtime (Now in progress...)<br>
6. Scheduler (Now in progress...)<br>
7. <code>fork(2)</code>, <code>exit(2)</code>, <code>wait(2)</code>, <code>kill(2)</code>, with same arguments as those specified in POSIX (Not yet)<br>
8. Process memory sharing and copy-on-write (Not yet)<br>
9. Concurrency maintaining through locks (Not yet)<br>
10. File system, including devfs (Not yet, disk file system impossible for lacking of hard disks, may have to create a ramdisk or implement <code>tmpfs</code>?)<br>
11. Necessary userland applications (Not yet)<br>
12. SMP Multiprocessor support (Not yet)  </p>

<p>My plans (or more precisely, daydreams)<br>
13. Signals (to prevent userland programs from crashing kernels)<br>
14. Security (although I frequently create bugs and frustrates myself)<br>
15. Dynamic linking (which means I have to create a dynamic C runtime library on my own)<br>
16. Cleaner code and organization (I struggle to stick on Linus' coding standard and tried to write better, but some of my code is still messy)<br>
16. Berkeley FFS (I have to read the paper and Linux source code)  </p>
      </section>
    </div>

    
  </body>
</html>